---
title: "An Empirical Study of Potentially Malicious Third-Party Libraries in Android Apps by Z. Zhang, W. Diao. C. Hu, S. Guo, C. Zuo, and L. Li"
date: 2020-09-28
type: book
commentable: true

# Provide the name of the presenter
summary: "Presenters: Dawei Yang and Matthew Sahara"

# Provide other tags that describe the paper
tags:
- teaching
- ee693e
- mobile app security
---

***
## Paper Summary
This paper provides a comprehensive study on the behaviors and features of potentially malicious libraries (PMLs) in Android application Packages (APKs). The authors designed and implemented an automated library extractor, LibExtractor. LibExractor can extract and cluster library candidates from large-scale apps efficiently. LibExtractor only takes one second average for processing one APK compared to the existing tools which take more than one minute. LibExtractor is resilient to package name obfuscations, since it uses relative paths for each class. After abstracting and clustering a huge set of library candidates, they analyzed those candidates by scanning them with an online malware detection platform and applying behavior matching. They analyzed 217,027 apps and 316,437 malware samples and found 4,957 PMLs. They also classified those PMLs based on their malicious behaviors.
***

## Presentation
{{< youtube 50txgBv-9LU >}}
***

## Review
### Strengths
- This paper shows how the authors design and implement an algorithm to identify and cluster library candidates in detail.
- PMLs are experimentally identified using LibExtractor and then analyzed for common features and concerning permissions.
- The results of PML extraction are clearly documented, visualized, and explained.

### Weaknesses
- This paper does not include some key features of their design and implementation, such as a pseudo-code of the Feature Value Generation Algorithm.
- The results of this paper are not very conclusive. The solution is clearly outlined and analyzed, but no clear conclusion/effects are drawn in context.
- The analysis of large sets of PMLs are difficult because there are so many variations. A focused solution to a specific issue/set of PMLs may be better.

### Detalied Comments
**Strengths:** This paper clearly documents the process and algorithm in parsing APKs for PMLs. The process is divided into 5 main steps, later explained in the Implementation section. The paper provides a very detailed explanation and reasoning for the method used to extract PMLs. Results, as highlighted in the Experimentation section of this report, are clearly stated, rationalized, and presented.

**Weakness:** As an example of missing key features, in Section 3.3, they explained how the LibExtractor generates a feature value for each library candidate in four rounds. They did not clearly explain how to pick the value from the first round, if two candidates get the same value from the previous round. It would be much clearer if they could provide pseudo-code.

In addition, this paper was not necessarily very conclusive. PMLs were identified using LibExtractor and VirusTotal, while subsequent limitations of the solution were discussed. Issues including accuracy of identification, obfuscation, clustering, and self-signed certificate discrepancies were identified in the Discussion and Limitations section, but no clear future works or conclusions were mentioned in detail. Existing solutions featured in the paper are divided into two major categories: Third-Party Library Identification and Malware Detection.

Parsing a large set of APKs to identify PMLs, while essential to preserve the privacy of the user, seems to be a difficult task, given the widespread obfuscation of these PMLs performed by numerous third parties. Perhaps it would be more efficient, comprehensive, and thorough to focus on a more specific solution to a specific issue. It may be worthwhile to identify the most common PMLs and their variations, and work toward accurate detection.

### Implementation
There are five steps of the implementation. First, diassemble the input APK file by Smali, and extract six different types of dependencies. They used Baksmali, a smali compiler, to assemble Java code to Smali code. Smali code includes many fields, and they extracted six of them for the next step. Second, build an inclusion-dependency graph, then divide the connected components. Based on the file tree that was generated by baksmali, they constructed an inclusion-dependency graph by connecting package nodes containing the same dependency. After that, they broke weakly connected components in that graph, and those separated components were defined as library candidates. Third, paths of candidates were replaced by relative paths and then ran four rounds of hashing in order to generate the unique feature value. Fourth, cluster libraries based on the feature values from the previous step. Fifth, virus scanning and harmful behavior matching, and they used an existing online malware detection platform to analyze extracted libraries and classified the PMLs by matching their behaviors.

{{< figure src="https://github.com/gustybear-teaching/course_ee693e_2020_fall/raw/main/week_06/images/pml_figure3.png" title="Class Dependency Steps" width="300" >}}

{{< figure src="https://github.com/gustybear-teaching/course_ee693e_2020_fall/raw/main/week_06/images/pml_overview.png" title="Overview of LibExtractor" width="600" >}}

As shown and described, the process of LibExtractor is separated into 5 major steps to obtain a list of PMLs from a set of APKs. In addition to LibExtractor, VirusTotal scanning was also used to process each PML as a DEX file, which was then scanned by multiple engines for malware.

Specific code used in the paper is not able to be found at this time. Alternatively, this is a link to download LibExtractor: [LibExtractor Download](https://www.gnu.org/software/libextractor/)

### Experimentation
After PMLs are identified, as mentioned in the previous section, the paper then provides an analysis covering library repackaging, potentially harmful behaviors, common permissions used by PMLs, and developer associations with apps and respective metadata. The declared dataset consisted of 4,957 PMLs with 207,137 known samples of malware.

{{< figure src="https://github.com/gustybear-teaching/course_ee693e_2020_fall/raw/main/week_06/images/pml_table3.png" title="Top Repackaged Libraries" width="300" >}}

The above table shows the top 10 repackaged libraries. On a side note, a Chinese ad firm *Youmi* made a public apology 4 years ago for discrete data-harvesting APIs, which definitely could be related. Looking back at the paper, from the data collected, it was determined that least 4.4% of PMLs are repackaged libraries. Additionally, they note that a seemingly benign library could be used to generate repackaged PMLs.

{{< figure src="https://github.com/gustybear-teaching/course_ee693e_2020_fall/raw/main/week_06/images/pml_harmfulbehav.png" title="Potentially Harmful Behaviors" width="600" >}}

In terms of experimental results of exposed potentially harmful behaviors, both *exposed components* and *exposed behaviors* are found. Exposed components occur when a PML purposefully leaves backdoors open for future exploitation by another application. Likewise, in the figure above, we view exposed potentially harmful behaviors exhibited which make up 6.9% of the malware detected in the current dataset. As we can see, the most common exposed behaviors consist of network config, phone information, and package. In addition to these exposed components and behaviors, we can additionally begin to categorize common permissions of PMLs, such as specific read and write permissions. Experimental results found that READ_PHONE_STATE and WRITE_EXTERNAL_STORAGE were used by nearly every app associated with a PML.

Additionally, there was also an attempt to determine associations between PMLs and their original developers based on app certificates. In the end, this method was deemed inconclusive, as most PMLs are incorporated by self-signed apps, and can have spurious information.

### Questions
1. Are there any permission access or security protocol to follow in order to extract libraries using LibExtracter?
It seems like LibExtractor focuses on extracting the metadata of files and their respective libraries. This process is only examining metadata, and therefore, should not be invasive or run into any permissions restrictions.
2. Could LibExtractor be used by app developers to determine if a third party library is safe to use?
The PML analysis using LibExtractor, outlined in the paper, will focus on the potential harmful behaviors idenfified in the code. Essentially, yes LibExtractor could in theory be applied in this way.
3. How can LibExtractor extract libraries from large-scale apps and identify malicious libraries?
LibExtractor looks at the metadata of a set of files to determine potentially harmful behavoirs and uses the information to identify PMLs. LibExtractor looks at the dependencies between classes to identify PMLs.
4. How accurately can LibExtractor identify repackaged libraries? It only states the percentage they detected but not how accurately it detected?
Correct, it does not seem that the authors published this information/statistic.
5. Since their approach depends on the dependence of classes, will it be affected if a malicious library deliberately adds (junk) classes of benign libraries?
Seeing that LibExtractor focuses on the dependencies of classes, it should be able to sort through an obfuscated class structure, as the paper states that it examines all class dependencies.
6. Would time bombs be effective in avoiding detection from LibExtractor? (Delayed execution)
Android applications require a specific, protected permission to allow apps to run in the background. This can be detected using LibExtractor.
7. Do PMLs only come from 3rd party installations, or can places like Google Play also expose the phone to PMLs?
Trusted downloads from the store, such as Google Play, are filtered and able to be trusted in many cases. However, we cannot ignore the fact that PMLs can be repackaged and hidden well enough to bypass the security measured in place by trusted partners. Note that PMLs are used in app development, and this answer is tailored to address the topic of PMLs in apps available from trusted sources.
8. Could attackers hide malware by manipulating the binary of a benign library and would their software? How would they go about detecting this?
Not completely sure what the student is asking, but to my understanding, this is encompassed by what the paper considers to be a repackaged library.
